"use strict";
/**
 * this script analyzed the apk using the tool appcheck.jar, 
 * then parses the bad results generated by this tool into a human readable text thats easy to read does not hurt the eye lol
 * 
 */
const fs = require('fs')
const path = require("path")
const { JavaCaller } = require('java-caller');
const utils = require("./utils")
const mv = require("./mv")
const APP_DATA_XSJ = "appdataxsj"
const APP_CHECK_JAR = "AppCheck.jar"
const command = `java -jar ${APP_CHECK_JAR} -Dfalse -Gtrue -Cfalse`
const jarPath = path.join(process.cwd(), APP_CHECK_JAR)
const GMS_OUTPUT = path.join(process.cwd(), APP_DATA_XSJ, "output_gms.txt")
const HMS_OUTPUT = path.join(process.cwd(), APP_DATA_XSJ, "output_hms.txt")
const appDataFolder = path.join(process.cwd(), APP_DATA_XSJ)
var debug = require("debug")("analyzer")

//includes hms sdk names
const headers = ["AppName", "account", "push",
    "iap", "location", "map",
    "analytics", "ads", "game",
    "drive", "scan", "safetydetect",
    "nearbyservice", "ml", "awareness",
    "fido", "health", "identity",
    "panorama", "site", "dtm",
    "wallet", "toolkit(G+H)"]

//todo: use GMS sdk names
const gmsHeadersMap = {
    "account": "Sign in",
    "push": "FCM",
    // "location": "location",
    "map": "maps",
    // "analytics": "analytics",
    // "ads": "ads",
    "game": "games",
    // "drive": "drive",
    "scan": "Firebase vision",
    "safetydetect": "safetynet",
    "nearbyservice": "nearby",
    // "ml": "ml",
    // "awareness": "awarness",
    // "fido": "fido",
    "health": "fitness",
    // "identity": "identity",
    "panorama": "Street View",
    "site": "places",
    "dtm": "GTM",
    "wallet": "pay",
}

/**
 * map HMS sdk names to GMS
 *  @param arr: array of hms kits, example:  ['push' , 'map','wallet','location']
 * @pram array of hms ktis with gms names, example: ['push (FCM)', 'map (maps)','wallet (pay)','location']
 */
const mapSdkNames = arr => {
    var res = []
    if (!arr) return res
    var keys = Object.keys(gmsHeadersMap)
    arr.forEach(sdk => {
        res.push(
            keys.includes(sdk) ? `sdk (${gmsHeadersMap[sdk]})` : sdk
        )
    })
}
/**
 * delete all apks in data folder, to avoid re-analyzing them or just to save space
 * @returns 
 */
const cleanDataFolder = async () => {
    if (!fs.existsSync(appDataFolder))
        return;
    var files = fs.readdirSync(appDataFolder)

    if (!files || files.length == 0)
        return
    files.forEach(file => {
        if (file.match(".*.apk")) {
            const filePath = path.join(appDataFolder, file)
            try {
                fs.unlinkSync(filePath)
                debug('analyzer:deleted ' + file + " from analyzer folder")
            } catch (e) {
                debug(e)
                debug('analyzer:failed to delete apk: ' + filePath)
            }
        }
    })
}
/**
 * 
 * @param {obj{packageName:apkPath}} packageNamesObj 
 * @param {boolean} enablelogs 
 * @returns promise resolved when all apks in packageNamesObj are analyzed 
 * result example = { 
      'com.landmarkgroup.splashfashions': {
      HMS: [ 'push' ],
      GMS: [ 'account', 'push', 'location', 'map', 'analytics', 'ads' ]
      }
 * 
 */
const analyzeAPKs = (apps) => new Promise(async (resolve, reject) => {
    debug("analyzer:analyzing ", apps)
    if (!fs.existsSync(appDataFolder))
        fs.mkdirSync(appDataFolder)

    //2- move apks from /downloads to /appdataxsj
    apps.forEach(async (app) => {
        const dest = path.join(appDataFolder, `${app.packageName}.apk`)
        try {
            if (global.keepApks)
                fs.copyFileSync(app.filePath, dest)
            else
                await mv.moveFile(app.filePath, dest)
            app.filePath = dest
        } catch (e) {
            debug("analyzer:failed to move apk " + app.packageName + ".apk" + " from /downloads to /appdataxsj")
            debug('analyzer:apk path= ' + app.filePath + " ,dest = " + dest)
            console.debug("⤫ failed to analyze apk of " + app.packageName)
            debug(e)
        }
    })

    //3- analyze using AppCheck 
    const java = new JavaCaller({
        jar: APP_CHECK_JAR
    });

    fs.writeFileSync(HMS_OUTPUT, '')
    fs.writeFileSync(GMS_OUTPUT, '')

    const { status, stdout, stderr } = await java.run(["-Gtrue -Dfalse -Cfalse"]);
    //    debug("--- status ----")
    //    debug(status)
    //    debug("--- stdout ----")
    //    debug(stdout)
    //    debug("--- stderr ----")
    //    debug(stderr)

    //4- parse bad AppCheck results

    const hmsOutput = fs.readFileSync(HMS_OUTPUT, 'utf-8')
    const gmsOutput = fs.readFileSync(GMS_OUTPUT, 'utf-8')

    const getEntries = (data) => {
        const entries = []
        data.split('\n').map(line => {
            entries.push(
                line.split('\t').map(l => l.trim()).filter(l => l.length > 0).filter(entry => !headers.includes(entry))
            )
        })
        return entries.filter(arr => arr.length > 0)
    }

    var hmsEntries = getEntries(hmsOutput)
    var gmsEntries = getEntries(gmsOutput)

    // console.log("hms entries",hmsEntries)
    const getKits = async (apps, headers) => new Promise((ress, rej) => {
        try {

            const res = {}
            apps.filter(entries => entries.length > 0).forEach(appEntries => {

                var kits = appEntries.slice(1, appEntries.length - 2)
                    .map((val, index) => val == "true" ? headers[index + 1] : "")
                    .filter(v => v && v.length > 0)
                const packageName = appEntries[0].replace('.apk', '')
                res[packageName] = kits
            })

            ress(res)
        } catch (e) {
            rej(e)
        }
    })

    const allHms = await getKits(hmsEntries, headers)
    const allGms = await getKits(gmsEntries, headers)

    var result = {}
    for (let app of apps) {
        const packageName = app.packageName

        var manifestData = { metaData: [] }
        var androidMarket = "⚠"
        var appId = "⚠"
        var versionName = "⚠"

        try {
            manifestData = await utils.getApkInfo(app.filePath)

            // console.dir(manifestData)
            versionName = manifestData ? manifestData.versionName : "NOT FOUND"

            debug("manifest of " + app.packageName + " is " + typeof manifestData)
            const metaData = manifestData['application']['metaDatas']

            const appIdObj = metaData.find(v => v.name == "com.huawei.hms.client.appid")
            appId = appIdObj ? appIdObj.value : "NOT FOUND"

            const androidMarketObj = metaData.find(v => v.name == "com.huawei.hms.client.channel.androidMarket")
            androidMarket = androidMarketObj ? JSON.stringify(androidMarketObj) : "NOT FOUND"

        } catch (e) {
            debug("analyzer:failed to parse apk ", packageName)
            //hmmms is an XAPK? a split APK? 
            debug(e)
        }

        result[packageName] = {
            version: versionName,
            GMS: mapSdkNames(allGms[packageName] || []),
            HMS: allHms[packageName] || [],
            "huawei App Id": appId,
            "androidMarket metadata": androidMarket
        }
    }
    resolve(result)

})



module.exports = {
    APP_CHECK_JAR,
    cleanDataFolder,
    analyzeAPKs
}

