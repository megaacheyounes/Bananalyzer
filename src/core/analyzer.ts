import { decompileApk } from './apktool/decompile';
('use strict');
import debugModule from 'debug';
/**
 * this script analyzed the apk using the tool appcheck.jar,
 * then parses the bad results generated by this tool into a human readable text thats easy to read does not hurt the eye lol
 *
 */
import fs from 'fs';
import path from 'path';

import { APP_DATA_FOLDER, UNKNOWN_INFO, GOOGLE_MESSAGING_EVENT } from '../consts';
import { AnalyzedApk, AnalyzedApp, AnalyzedManifest } from '../models/analyzedApp';
import { APK } from '../models/apk';
import { Action, Activity, AndroidManifest, IntentFilter, MetaData, Service, UsesPermission } from '../models/manifest';
import { getApkInfo } from './utils';
import { HUAWEI_MESSAGING_EVENT } from '../consts';
import { analyzeKits } from './analyzer/AnalyzeKits';
import { getAndroidManifestData } from '../utils/manifestReader';

const debug = debugModule('analyzer');

//to find messaging services
const MESSAGING_EVENT = 'MESSAGING_EVENT';

/**
 *
 * @param {array} apks: list of downloaded apps/apk to analyze, example = [
 * {packageName:"package.name":filePath:"path/to/file.apk", uploadDate:"may 27, 2021"}
 * ]
 * @return {AnalyzedApp[]} resolved when all apks in packageNamesObj are analyzed
 * result example = {
 *    'com.landmarkgroup.splashfashions': {
 *     HMS: [ 'push' ],
 *      GMS: [ 'account', 'push', 'location', 'map', 'analytics', 'ads' ]
 *   }
 */
export const analyzeAPKs = (apks: APK[], keepApks: boolean = true): Promise<AnalyzedApp[]> =>
  new Promise<AnalyzedApp[]>(async (resolve, reject) => {
    debug('analyzer:analyzing ', apks);

    if (!fs.existsSync(APP_DATA_FOLDER)) fs.mkdirSync(APP_DATA_FOLDER);
    const results: AnalyzedApp[] = [];

    for (const apk of apks) {
      const decRes = await decompileApk(apk, true);
      if (!!decRes.error) {
        continue;
      }
      debug('decRes', decRes);
      const SDKs = await analyzeKits(apk);
      debug('sdks', SDKs);
      const manifestResult = await analyzeManifest(decRes.manifestPath!);
      debug('manifestResult', manifestResult);
      const apkFileResult = analyzeApk(apk);
      debug('apkfileresult', apkFileResult);

      results.push({
        ...SDKs,
        ...manifestResult,
        ...apkFileResult,
      });
    }

    resolve(results);
  });

/*** parse manifest */
const getCompanyMetadata = (manifestData: AndroidManifest, company: string) =>
  manifestData.application.metaData
    ?.filter((m) => !!m.name && m.name.toLowerCase().indexOf(company) != -1)
    .map((m) => `${m.name}=${m.value}`) || [];

const getPermissions = (manifestData: AndroidManifest, company: string) =>
  manifestData.usesPermissions
    ?.map((obj: UsesPermission | any) => obj.name || obj[''])
    .filter((p: string) => !!p && p.length > 0)
    .filter((p: string) => p.toLowerCase().indexOf(company) != -1) || [];

const getServices = (manifestData: AndroidManifest, prefix: string) =>
  manifestData.application.services
    ?.map((a: Service) => a.name)
    .filter((a: string) => !!a && a.indexOf(prefix) != -1) || [];

const getMessagingService = (manifestData: AndroidManifest, actionName: string) =>
  manifestData.application.services
    ?.filter(
      (s: Service) =>
        s.intentFilters
          ?.map((i: IntentFilter) => i.action?.map((action: Action) => action.name))
          .join(',')
          .indexOf(actionName) != -1
    )
    .map((s: Service) => s.name) || [];

const getActivities = (manifestData: AndroidManifest, prefix: string) =>
  manifestData.application.activities
    .map((a: Activity) => a.name)
    .filter((a: string) => !!a && a.indexOf(prefix) != -1) || [];

const analyzeManifest = async (manifestPath: string): Promise<AnalyzedManifest> => {
  let packageName: string = UNKNOWN_INFO;
  let huaweiAppId = UNKNOWN_INFO;
  let versionName = UNKNOWN_INFO;
  let googlePermissions: string[] = [UNKNOWN_INFO];
  let huaweiPermissions: string[] = [UNKNOWN_INFO];

  let googleMetadata: string[] = [UNKNOWN_INFO];
  let huaweiMetadata: string[] = [UNKNOWN_INFO];

  let googleActivities: string[] = [UNKNOWN_INFO];
  let huaweiActivities: string[] = [UNKNOWN_INFO];

  let googleServices: string[] = [UNKNOWN_INFO];
  let huaweiServices: string[] = [UNKNOWN_INFO];

  let googleMessagingServices: string[] = [UNKNOWN_INFO];
  let huaweiMessagingServices: string[] = [UNKNOWN_INFO];

  try {
    const manifestData: AndroidManifest = await getAndroidManifestData(manifestPath);

    packageName = manifestData.package;

    // console.dir(manifestData)
    versionName = manifestData ? manifestData.versionName : 'NOT FOUND';

    const metadata = manifestData['application']['metaData'];

    googlePermissions = getPermissions(manifestData, 'google');
    huaweiPermissions = getPermissions(manifestData, 'huawei');

    if (!!metadata) {
      const appIdObj = metadata?.find((v) => v.name == 'com.huawei.hms.client.appid');

      let huaweiAppId: string;
      if (!!appIdObj) {
        huaweiAppId = `C${appIdObj.value}`.replace('appid=', '');
      } else {
        huaweiAppId = '';
      }

      huaweiMetadata = getCompanyMetadata(manifestData, 'huawei');
      googleMetadata = getCompanyMetadata(manifestData, 'google');
    }

    googleActivities = getActivities(manifestData, 'com.google');
    huaweiActivities = getActivities(manifestData, 'com.huawei');

    googleServices = getServices(manifestData, 'com.google');
    huaweiServices = getServices(manifestData, 'com.huawei');

    googleMessagingServices = getMessagingService(manifestData, GOOGLE_MESSAGING_EVENT);
    huaweiMessagingServices = getMessagingService(manifestData, HUAWEI_MESSAGING_EVENT);
  } catch (e: any) {
    debug('analyzer:failed to parse apk ', packageName);
    // hmmm is an XAPK? a split APK?
    console.log(`⤫ failed to parse AndroidManifest.xml → ${packageName} : ${e.message}`);
    debug(e);
  }

  return {
    packageName,
    versionName,
    huaweiAppId,
    googleMetadata,
    huaweiMetadata,
    googlePermissions,
    huaweiPermissions,
    googleActivities,
    huaweiActivities,
    googleServices,
    huaweiServices,
    googleMessagingServices,
    huaweiMessagingServices,
  };
};

const analyzeApk = (apk: APK): AnalyzedApk => {
  // get apk last modification  time
  let apkCreationTime = '';
  try {
    const stat = fs.statSync(apk.filePath);
    // console.log(stat);
    if (!!stat.mtime) apkCreationTime = stat.mtime.toLocaleString();
  } catch (e) {
    debug(e);
  }
  return {
    uploadDate: apk.uploadDate || '',
    apkCreationTime,
  };
};
